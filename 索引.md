# 索引



## 一、索引概念

- 索引优化数据库查询速度的是一种**数据结构**
- InnoDB：B+树
  - B+树层数**越低**，IO次数**越少**
  - 一般情况下，我们用到的**B+树层数不会超过4层**
  - B+树时间复杂度log1.44(n)





## 二、常见的索引

### 1. 聚簇索引

#### 概念

- 聚簇索引并不是一种单独的引用类型，而是**一种数据存储方式**（所有的用户都记录在了叶子节点），也就是所谓的 **索引即数据，数据即索引**

[^术语“聚簇”表示数据行和相邻的键值聚簇地存储在一起]: 

#### 特点

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
   - **页内** 的记录是安装主键的大小排序成一个单向链表
   - 各个存放 **用户记录页** 也是根据页中用户记录的主键大小顺序排成一个**双向链表**
   - 存放 **目录项记录的页** 分为不同的层次，在同一层次中的页也是按照页中目录项记录的主键大小排序成一个 **双向链表**
2. B+树的**叶子节点存储**的是完整的用户记录
   - 所谓的完整用户记录，就是指的这个记录中存储了索引列的值（包括隐藏列）

- 我们把具有这两种特性的B+树称为聚簇索引，索引完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显示地使用INDEX语句去创建，**InnoDB** 存储引擎会**自动**为我们**创建**聚簇索引。

#### 优点

- **数据访问更快**
- 聚簇索引对于主键的**排序查找和范围查找**速度非常快
- 节省了大量IO操作

#### 缺点

- 插入速度严重依赖于**插入顺序**。对于InnoDB表我们一般会定义一个自增的ID列为主键
- 更新主键的代价很高。在InnoDB表**主键**一般定义为为**不可更新**
- 二级索引访问需要两次索引查找，第一次找主键值，第二次根据主键值找行数据

#### 限制

- 目前只有InnoDB支持聚簇索引
- 每个MySQL的表只能有**一个聚簇索引**
- 如果定义主键，InnoDB会选择一个**非空且唯一索引**代替，如果没有，会隐式定义一个主键来作为聚簇索引
- InnoDB表的主键尽量选用有序的ID， 而不建议用无序的ID（比如UUID\MD5\HASH\字符串列）



### 2. 二级索引（辅助索引、非聚簇索引）

- 使用**其他字段**构建二级索引
- 二级索引由其**字段和主键**构成，不包含完整记录，聚簇索引是包含完整记录的

- 使用二级索引查找后，进行**回表**操作，通过聚簇索引，找到其对应的完整记录
- 二级索引相当于存储的是**数据位置**
- 一个表可以有多个聚簇索引
- 使用聚簇索引时，数据查询效率高，但是对数据进行改删增等操作，效率会比非聚簇索引低



### 3. 联合索引

- 联合索引本质也是二级索引
- 使用 **多个字段** 组合联合构建索引

- 比如使用c2,c3两个字段联合构建索引， 每条目录页有**c2,c3,页号**三部分组成，先按照c2值进行排序，如果c2一样再按照c3进行排序；b+树叶子节点出的用户记录由**c2,c3和主键c1**列组成



## 三、关于引擎

### 1. InnoDB注意事项

- 根页面位置万年不动。
  - B+树是从根节点开始发展， 聚簇索引不是人为创建的，默认就有，创建表的时候都会创建一个根节点页面
  - 根节点空间用完后会，将记录重新复制到一个新分配的页进行页分裂操作等，**根节点升级为目录页**
- 内节点中目录项记录的唯一性
- 一个页面最少存储2条记录



### 2. MyISAM引擎

- MyISAM的**索引文件仅保存数据记录的地址**，其存储中，数据文件和索引文件是两个文件；InnoDB的索引文件和数据文件是同个文件。



### 3. InnoDB与MyISAM对比

1. 在InnoDB存储引擎中，我们只需要根据主键值对 **聚簇索引** 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着**MyISAM中建立的索引相当于全部都是 二级索引 。**
2.  InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 **分离**的 ，索引文件仅保存数据记录的**地址**。
3.  InnoDB的非聚簇索引data域存储相应记录 **主键的值** ，而MyISAM索引记录的是 **地址** 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。
4. MyISAM的回表操作是十分 **快速** 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。
5.  InnoDB要求表 **必须有主键 （ MyISAM可以没有 ）**。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。



## 四、索引的代价

- **空间上的代价**
  - 每个索引都有颗B+树，一页默认16KB
- **时间上的代价**
  - 进行`增 删 改` 操作，都会去修改B+树索引，增加时间



## 五、MySQL数据结构选择的合理性

- 磁盘的**I/O操作次数**对索引的使用效率至关重要



1. Hash结构

   - Hash本身是一个散列函数
   - 相同的输入永远可以得到相同的输出
   - 加快查找速度的数据结构，常见有2类
     - 树，类如平衡二叉树，增删查改的平均时间复杂度都是**O(log2N)**;
     - 哈希，类如HashMap，增删查改的平均时间复杂度都是**O(1)**; (key，value)
   - InnoDB本身不支持hash索引，但是提供 `自适应Hash索引` ，如果某个数据经常被访问，当满足一定条件时，就会将这个数据页放入Hash表、
   - 问为什么数据库不选择Hash索引

   ```sql
   /*
   
   对于这样一个单行查询的SQL需求： select * from t where name=”john”; 确实是哈希索引更快，因为每次都只查询一条记录。 所以，如果业务需求都是单行访问，例如passport，确实可以使用哈希索引。
   
   但是对于排序查询的SQL需求： 分组：group by 排序：order by 比较：
   
   哈希型的索引，时间复杂度会退化为O(n)，而树型的“有序”特性，依然能够保持O(log(n)) 的高效率。 
   */
   ```

   



## 六、行格式

### 1. 行溢出

- 一个页的大小一般为16KB，也就是16384字节，而一个CARCHARM(M)类型的列就最多可以存储65533个字节，这样就出现**一个页存放不了一条记录**，这个现象就成为行溢出



### 2. 四种行格式

- MySQL5.7默认**Compact**，MySQL默认**Dynamic**

- 查看表行格式

```sql
SHOW TABLE STATUS like 'emp1';
```

- 修改行格式

```sql
ALTER TABLE emp1 row_format=compact;
```

- 四种行格式区别

| **行格式** | 紧凑存储 | 增强的可变长度列存储 | **大索引键前缀支持** | 支持压缩 |
| ---------- | -------- | -------------------- | -------------------- | -------- |
| REDUNDANT  | 否       | 否                   | 否                   | 否       |
| COMPACT    | 是       | 否                   | 否                   | 否       |
| DYNAMIC    | 是       | 是                   | 是                   | 否       |
| COMPRESSED | 是       | 是                   | 是                   | 是       |

- Compact和Dynamic区别
  - MySQL5.7默认使用的行格式就是DYNAMIC了，它和COMPACT非常像，是COMPACT的一个变体。
  - 区别是在处理「溢出列」时，COMPACT会在「真实数据」处存储前768字节数据+20字节指针，而DYNAMIC只会存储20字节指针，溢出列的所有数据全部存储在「溢出页」中。 
  - COMPRESSED的特点是它可以使用压缩算法对页面进行压缩，包括「溢出页」，这对于像长文本、TEXT、BLOB类型的数据来说，可以极大的节省空间。但是检索数据时，必须先解压才可以进行后续操作，这会消耗更多的CPU资源，CPU和磁盘IO两者的开销，需要各位去权衡。

- 小结
  - 绝大多数存储引擎将数据持久化存储在磁盘中，行格式决定了记录在磁盘上的存储格式。
  - InnoDB引擎目前共支持四种行格式
  - 古老的REDUNDANT设计的简单粗暴，缺点是会占用更多的磁盘空间，间接影响了DML操作的效率，查询需要更多的磁盘IO。
  - COMPACT行格式设计的非常紧凑，也更加的复杂，能用Bit表示就绝不用Byte，是一个非常经典的行格式。
  - DYNAMIC和COMPRESSED是COMPACT的两种变体，在处理溢出列时稍有不同，后者支持对页面进行压缩，通过消耗CPU算力还换取磁盘IO的性能。





## 七、索引的分类

- 从`功能逻辑`上说，分为**普通索引，唯一索引（声明唯一性字段自动生成），主键索引，全文索引**
  - 全文检索一般是使用ES（Elasticsearch）

- 按照`物理实现方式`，索引分为**聚簇索引**和**非聚簇索引**
- 按照`作用字段个数`，分为**单列索引**和**联合索引**
  - 联合索引遵循**最左前缀集合**，比如在字段id,name和gender建议联合索引idx_id_name_gender，只有在查询条件使用了字段id时才会被使用



## 八、创建索引

### 查询索引方式

- **SHOW CREATE TABLE table_name;**
- **SHOW INDEX FROM table_name;**



### **CREATE TABLE** 

- 隐式创建索引：声明主键约束、唯一性约束、外键约束

```SQL
CREATE TABLE dept(
	dept_id INT PRIMARY KEY,
    dept_name VARCHAR(20)
);
```

- 显示创建索引
  - **UNIQUE 、 FULLTEXT 和 SPATIAL** 为可选参数，分别表示唯一索引、全文索引和空间索引； 
  - **INDEX 与 KEY** 为同义词，两者的作用相同，用来指定创建索引； 
  - **index_name** 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；
  - **col_name** 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； 
  - **length** 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； 
  - **ASC 或 DESC** 指定升序或者降序的索引值存储。

```sql
CREATE TABLE table_name [col_name data_type]
[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]
```

example:

```sql
#创建普通索引
CREATE TABLE book(
	book_id INT ,
	book_name VARCHAR(100),
	AUTHORS VARCHAR(100),
	info VARCHAR(100) ,
	COMMENT VARCHAR(100),
	year_publication YEAR,
	INDEX idxbname(year_publication)
);

#显示创建唯一性索引
CREATE TABLE book2(
	book_id INT ,
    boot_name VARCHAR(15),
	UNIQUE INDEX uk_idx_bn(boot_name)
);
#此时boot_name字段自动产生唯一性约束！

#主键索引，隐式创建
CREATE TABLE book3(
	book_id INT PRIMARY KEY,
    boot_name VARCHAR(15),
);
#删除约束来删除索引
ALTER TABLE book3
DROP PRIMARY KEY;

#创建联合索引
CREATE TABLE book4(
	book_id INT PRIMARY KEY,
	boot_name VARCHAR(15),
	INDEX mul_id_name(book_id,boot_name)
);
```



### **ALTER TABLE** 

- 语法：

```sql
ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]
[index_name] (col_name[length],...) [ASC | DESC]
```

example:

```sql
ALTER TABLE book4
ADD UNIQUE INDEX idx_name(boot_name);
```



### **CREATE INDEX**

- 
- 语法：

```sql
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
ON table_name (col_name[length],...) [ASC | DESC]
```

example

```sql
CREATE INDEX idx_name ON book3(boot_name);
```





## 九、删除索引

### ALTER TABLE

- 语法：

```sql
ALTER TABLE table_name DROP INDEX index_name;
```

### DROP INDEX

- 语法

```SQL
DROP INDEX index_name ON table_name
```

### 注意事项

- 删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。**如果组成 索引的所有列都被删除，则整个索引将被删除**。
- 添加**AUTO_INCREMENT**约束字段的唯一索引**不能被删除**。



## 十、MySQL8.0索引新特性

### 支持降序索引（仅限于InnoDB引擎）

- 升序索引使用反向扫描时，大大降低了效率

example:

```sql
CREATE TABLE ts1(
	a INT,
	b INT,
	INDEX idx_a_b(a ASC, b DESC)
);

SHOW CREATE TABLE ts1;
```



### 支持隐藏索引

1.概念

- 将索引设置成隐藏索引，则查询优化器不会调用该索引
- 将需要删除的索引设置成隐藏索引，然后进行正常测试， 之后再删除该索引，是种安全删除的技巧

- 主键不能设置为隐藏索引
- 隐藏索引仍然会和正常索引一样实时更新

2.创建隐式索引

- INVISIBALE

```SQL
CREATE TABLE book5(
	book_id INT PRIMARY KEY,
	boot_name VARCHAR(15),
	INDEX idx_name(boot_name) INVISIBLE
);

SHOW INDEX FROM book5;
#visible选项 为 NO
/*
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| book5 |          0 | PRIMARY  |            1 | book_id     | A         |           0 | NULL     | NULL   |      | BTREE      |         |               | YES     | NULL       |
| book5 |          1 | idx_name |            1 | boot_name   | A         |           0 | NULL     | NULL   | YES  | BTREE      |         |               | NO      | NULL       |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
*/
```

- ALTER TABLE

  ```sql
  ALTER TABLE book5
  ALTER INDEX idx_name INVISIBLE;
  ```

  



## 十一、索引的设计原则

- 索引设计不合理或缺少都会对数据库性能造成影响



### 哪些情况适合创建索引

#### 1.字段的数值有唯一性的限制

- 业务上具有**唯一特性**的字段，即使**是组合字段，也必须建成唯一索引**。（来源：Alibaba） 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。

#### 2.频繁作为 **WHERE** 查询条件的字段

#### 3.经常 **GROUP BY 和 ORDER BY** 的列

- 索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 **GROUP BY** 对数据进行分组查询，或者 使用 **ORDER BY** 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。如果**待排序的列有多个**，那么可以在这些列上建立 **组合索引** 。
- 如果同时使用GROUP BY 和 ORDER BY 同时使用，建立联合索引，根据执行顺序， 因**GROUP BY先执行**，所以GROUP BY查询的字段放置左边

```sql
#student_id声明在左边， 下面查询时间0.281s
CREATE INDEX idx_sid_time ON student_info(student_id, create_time);

#create_time声明在左边， 下面查询时间1.302s
CREATE INDEX idx_sid_time ON student_info(create_time,student_id);

SELECT student_id, COUNT(*) AS num FROM student_info 
GROUP BY student_id 
ORDER BY create_time DESC 
LIMIT 100;
```

- 但是GROUP BY有时候创建单列索引**反而降低效率**，需实际测试

#### 4.**UPDATE、DELETE 的 WHERE** 条件列

- 对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就 能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或 删除。**如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更 新不需要对索引进行维护。**

#### 5.**DISTINCT** 字段需要创建索引

#### 6.多表 JOIN 连接操作时，创建索引注意事项

- 连接表的数量尽量不要超过 **3** 张 
- 对 **WHERE** 条件创建索引
-  对用于**连接的字段**创建索引，并且该字段在多张表中的 **类型必须一致**

#### 7.使用列的类型小的创建索引

- 数据范围小的类型
- 数据类型越小，在查询时进行的比较操作越快
- 数据类型越小，索引占用的存储空间越少，减少磁盘I/O损耗
- 这个建议对**主键来说更加适用**

#### 8.使用字符串**前缀**创建索引

- 因字符串越长，在索引中**占用的存储空间越大**，在做字符串比较时**占用更多的时间**
- 截取字段的前面一部分内容建立索引，这叫做**前缀索引**
- 阿里巴巴开发建议：**【 强制 】**在 **varchar** 字段上建立索引时，**必须指定索引长度**，没必要对全字段建立索引，根据实际文本 区分度决定索引长度。

```sql
CREATE TABLE shop(address VARCHAR(120) NOT NULL);
#创建前缀索引
ALTER TABLE shop ADD INDEX(address(12));
```

#### 9.区分度高（散列性高）的列适合作为索引

- `列的基数`指的是某一列中**不重复数据的个数**

- 在记录行数一定的情况下，列的**基数越大**，该列的值**越分散**；列的基数越小，该列的值越集中。

- 区分度高的适合创建索引

- 联合索引把区分度高（散列性高）的列放在前面

- 使用公式计算区分度，越接近1越好，一般**超过33%**就算比较**高效**的索引

  ```SQL
  SELECT COUNT(distinct a)/COUNT(*) FROM t1;
  ```

#### 10.使用最频繁的列放在联合索引的最左边

#### 11.在多个字段都要创建索引的情况下，联合索引优于单值索引





### 限制索引数目

- 在实际工作中，建议单张表索引数量不超过6个
  - 每个索引都需要占用磁盘空间
  - 索引会影响INSERT DELETE UPDATE 等语句性能
  - 优化器在选择优化查询时，会对每个可以用到的**索引进行评估**，索引越多越增加该步骤负担





### 哪些情况不适合创建索引

#### 1.在where中使用不到的字段，不要设置索引

#### 2.数据量小的表最好不要使用索引

- 在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。

#### 3.有大量重复数据的列上不要建立索

- 相对于区分度低
- 当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引。

#### 4.避免对经常更新的表创建过多的索引

- 频繁更新的字段不一定要创建索引，每次更新数据的时候都需要更新索引，如果索引太多会造成负担
- 避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时提高的查询速度，同时降低了更新表的速度

#### 5.不建议用无序的值作为索引

- 例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字 符串等。

#### 6.删除不再使用或者很少使用的索引

#### 7.不要定义冗余或重复的索引

- 冗余索引
  - 举例

```sql
CREATE TABLE person_info(
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),
    KEY idx_name (name(10))
);

#我们知道，通过 idx_name_birthday_phone_number 索引就可以对 name 列进行快速搜索，再创建一 个专门针对 name 列的索引就算是一个 冗余索引 ，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。
```

- 重复索引
  - 举例

```sql
CREATE TABLE repeat_index_demo (
    col1 INT PRIMARY KEY,
    col2 INT,
    UNIQUE uk_idx_c1 (col1),
    INDEX idx_c1 (col1)
);

#我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。
```

